# -*- coding: utf-8 -*-
"""Predicting_House_Prices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IRC-q_l0tOml19BlzrPAzgMxW44R4O7X
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

data = pd.read_csv("/content/mission 2.csv")

data.head(10)

data.isna().sum()

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()

data['Location'] =  le.fit_transform(data['Location'])

data.info()

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
data[['Size (sqft)',  'Bedrooms', 'Bathrooms', 'Year Built', 'Condition']] = sc.fit_transform(
    data[['Size (sqft)',  'Bedrooms', 'Bathrooms', 'Year Built', 'Condition']])

data.columns

data.head()

data.describe()

plt.figure(figsize=(10,10))
sns.histplot(data['Price'], color="green", kde=True)
plt.title = 'Price Distribution'
plt.xlable = "Price"
plt.ylable= "Frequency"
plt.show()

plt.figure(figsize=(10,10))
sns.scatterplot(x=data['Price'], y= data['Size (sqft)'], color="green")
plt.title = 'Price & Size Relation'
plt.xlable = "Price"
plt.ylable= "Size"
plt.show()

plt.figure(figsize=(10,10))
sns.barplot(x=data['Location'],y=data['Price'], color="blue")
plt.title = 'impact of location on price'
plt.xlable = "location"
plt.ylable= "Price"
plt.show()

from sklearn.model_selection import train_test_split
x = data.drop('Price', axis=1)
y =data['Price']
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.2, random_state=42)

from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score,mean_absolute_error

lr = LinearRegression()
dt = DecisionTreeRegressor()
rf = RandomForestRegressor()
lr.fit(x_train, y_train)
dt.fit(x_train, y_train)
rf.fit(x_train, y_train)

y_predict_lr = lr.predict(x_test)
y_predict_dt = dt.predict(x_test)
y_predict_rf = rf.predict(x_test)

print("Linear Regression MSE:", mean_squared_error(y_test, y_predict_lr))
print("DecisionTreeRegressor MSE:", mean_squared_error(y_test, y_predict_dt))
print("Random Forest MSE:", mean_squared_error(y_test, y_predict_rf))

print("Linear Regression MSE:", mean_absolute_error(y_test, y_predict_lr))
print("DecisionTreeRegressor MSE:", mean_absolute_error(y_test, y_predict_dt))
print("Random Forest MSE:", mean_absolute_error(y_test, y_predict_rf))

print("r2_score Linear Regression:", r2_score(y_test, y_predict_lr))
print("r2_score DecisionTreeRegressor:", r2_score(y_test, y_predict_dt))
print("r2_score Random Forest:", r2_score(y_test, y_predict_rf))

plt.figure(figsize=(10, 8))
plt.scatter(y_test, y_predict_lr, color='blue', label='Linear Regression')
plt.scatter(y_test, y_predict_dt, color='green', label='Decision Tree')
plt.scatter(y_test, y_predict_rf, color='red', label='Random Forest')
plt.show()

from sklearn.model_selection import GridSearchCV, RandomizedSearchCV
# using Gridsearch
gird_params = {
    "max_depth": [5,15,10,20,30], "max_leaf_nodes": [10,20,30,50,15,5,7]
}
grid_search_model = GridSearchCV(estimator=DecisionTreeRegressor(), param_grid=gird_params, cv=5)
grid_search_model.fit(x_train, y_train)
grid_search_model.best_params_

grid_y_predict = grid_search_model.best_estimator_.predict(x_test)
print("r2_score GridSearch:", r2_score(y_test, grid_y_predict))
print("MSE GridSearch:", mean_squared_error(y_test, grid_y_predict))
print("MAE GridSearch:", mean_absolute_error(y_test, grid_y_predict))

random_params = {
    'max_depth': [5,15,10,20,30], "n_estimators": [100,200,300,400,500]
}

ranom_model = RandomizedSearchCV(estimator=RandomForestRegressor(), param_distributions=random_params, cv=5)
ranom_model.fit(x_train, y_train)
ranom_model.best_params_

random_y_predict = ranom_model.best_estimator_.predict(x_test)
print("r2_score Random Search:", r2_score(y_test,random_y_predict))
print("MSE Random Search:", mean_squared_error(y_test, random_y_predict))
print("MAE Random Search:", mean_absolute_error(y_test, random_y_predict))

pip install gradio

import gradio as gr
def predict_house_price(Location, Size, Bedrooms, Bathrooms, YearBuilt, Condition):
  # Create a DataFrame with the input data
    input_data = pd.DataFrame({
        'Location': [Location],
        'Size (sqft)': [Size],
        'Bedrooms': [Bedrooms],
        'Bathrooms': [Bathrooms],
        'Year Built': [YearBuilt],
        'Condition': [Condition]
    })

    # Encode the categorical column
    input_data['Location'] = le.transform(input_data['Location'])

    # Scale the numerical columns (assume scaling_cols contains the numeric column names)
    scaling_cols = ['Size (sqft)', 'Bedrooms', 'Bathrooms', 'Year Built', 'Condition']
    input_data[scaling_cols] = sc.transform(input_data[scaling_cols])

    # Predict the house price
    prediction = rf.predict(input_data)
    return f"Predicted House Price: ${prediction[0]:,.2f}"
gr.Interface(
    fn=predict_house_price,
    inputs=[
        gr.Dropdown(
            ["Suburban", "Urban", "Rural"], label="Location"),

        gr.Number(label="Size (sqft)"),
        gr.Number(label="Bedrooms"),
        gr.Number(label="Bathrooms"),
        gr.Number(label="Year Built"),
        gr.Number(label="Condition (1-5)")
    ],
    outputs="text",
    title="House Price Prediction"
).launch()

